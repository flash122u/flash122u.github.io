<!doctype html><html lang=en dir=auto data-theme=dark><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Solidity 学习记录_2_数据类型 | flash122u's blog</title><meta name=keywords content="Solidity,Web3,ETH"><meta name=description content="记录 Solidity 学习 2"><meta name=author content="flash122u"><link rel=canonical href=https://flash122u.github.io/posts/learn_solidity_2/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.343cc480b9ffc8f04ccbe5e968ad674880cab773ec19905e93033065c1e7a804.css integrity="sha256-NDzEgLn/yPBMy+XpaK1nSIDKt3PsGZBekwMwZcHnqAQ=" rel="preload stylesheet" as=style><link rel=icon href=https://flash122u.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://flash122u.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://flash122u.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://flash122u.github.io/apple-touch-icon.png><link rel=mask-icon href=https://flash122u.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://flash122u.github.io/posts/learn_solidity_2/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script>localStorage.getItem("pref-theme")==="light"&&(document.querySelector("html").dataset.theme="light")</script><script async defer data-website-id=630fc019-42d4-4053-894a-95f696994ca3 src=https://cloud.umami.is/script.js></script><meta property="og:url" content="https://flash122u.github.io/posts/learn_solidity_2/"><meta property="og:site_name" content="flash122u's blog"><meta property="og:title" content="Solidity 学习记录_2_数据类型"><meta property="og:description" content="记录 Solidity 学习 2"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2026-01-12T10:30:00+08:00"><meta property="article:modified_time" content="2026-01-12T10:30:00+08:00"><meta property="article:tag" content="Solidity"><meta property="article:tag" content="Web3"><meta property="article:tag" content="ETH"><meta property="og:image" content="https://flash122u.github.io/images/avatar.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://flash122u.github.io/images/avatar.png"><meta name=twitter:title content="Solidity 学习记录_2_数据类型"><meta name=twitter:description content="记录 Solidity 学习 2"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://flash122u.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Solidity 学习记录_2_数据类型","item":"https://flash122u.github.io/posts/learn_solidity_2/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Solidity 学习记录_2_数据类型","name":"Solidity 学习记录_2_数据类型","description":"记录 Solidity 学习 2","keywords":["Solidity","Web3","ETH"],"articleBody":"Solidity 数据类型小结 分类 核心内容 关键特性 类型体系 分为值类型、引用类型、映射类型三大类 Solidity 是静态类型语言，变量类型编译时确定 值类型 包含布尔、整型（uint/int）、地址、定长字节数组、枚举、函数类型等 1. 赋值/传参时值拷贝，修改副本不影响原变量\n2. 数据占用 ≤32 字节\n3. 示例：uint a=10; uint b=a; b=20; → a 仍为 10 引用类型 包含数组、结构体、string/bytes（动态字节数组）、合约 1. 数据占用通常 \u003e32 字节，支持引用传递减少拷贝开销\n2. 必须显式指定数据位置（memory/storage/calldata）\n3. 赋值规则：\n- 不同位置赋值 → 拷贝副本\n- 相同位置赋值 → 创建引用（修改新变量会影响原变量） 数据位置（引用类型专属） 4 种位置（transient 不支持引用类型） storage 存储状态变量，永久保存在区块链，Gas 消耗最高 memory 函数内临时存储，函数执行后释放，Gas 中等 calldata 存储 external 函数参数，只读不可修改，Gas 消耗最低 transient 单次交易内有效，不支持引用类型定义 映射类型 键值对结构（mapping(KeyType =\u003e ValueType)） 1. 类似字典/哈希表，仅支持作为状态变量（storage）\n2. 详细用法需结合后续数据结构章节学习 值类型 vs 引用类型\n值类型：拷贝传递，独立存储，适合简单数据。 引用类型：需指定数据位置，支持引用传递，适合复杂数据（数组、结构体等），可节省 Gas。 数据位置选择原则\n状态变量默认 storage； 函数内临时变量用 memory； external 函数参数优先用 calldata； 交易内临时共享数据用 transient（仅限值类型）。 赋值行为关键规则\n不同位置赋值→拷贝，相同位置赋值→引用。\nSolidity 整型（uint与int）小结 类别 核心内容 类型定义 1. 两类整型：uint（无符号整数，非负）、int（有符号整数，可正负）\n2. 位数范围：uint8-uint256、int8-int256，8位步进\n3. 默认类型：uint等价uint256，int等价int256 取值范围 1. uintN：0 ~ 2^N - 1（如uint8：0~255）\n2. intN：-2^(N-1) ~ 2^(N-1) - 1（如int8：-128~127）\n3. 默认值：所有整型变量未赋值时默认0 运算规则 1. 支持运算符：比较（\u003e/\u003c/==等）、算术（+/-/*///%/**）、位运算（\u0026/` Gas 优化 确定运算无溢出时，使用unchecked模式可节省 Gas（单次约省0.26%，循环场景效果显著） 使用场景选择 1. 优先用 uint：代币余额、数组索引、时间戳、计数器等非负场景\n2. 使用 int：温度、价格波动、数值差值等需表示正负的场景 常见陷阱\u0026避坑方案 1. 无符号下溢：uint x=0; x-1会回退 → 先判断x\u003e0再减法\n2. 除法截断：需精度时放大分子（如(5*1e18)/2）\n3. 类型转换截断：大类型转小类型前，用require(val \u003c= type(uint8).max)校验\n4. 跨类型比较：int与uint直接比较易出错 → 统一转换为相同类型再比较 进阶技巧 用type(X).min/type(X).max获取整型X的最值（如type(uint8).max=255） Solidity 布尔类型小结 分类 核心内容 关键说明/示例 基础特性 关键字、取值、默认值 关键字：bool；取值：true/false；默认值：false 核心运算符 逻辑运算符：\u0026\u0026（与）、` 短路求值 规则、优化技巧 规则：\u0026\u0026左false/` 典型应用 权限控制、状态管理、功能开关、条件判断 示例：\n1. 权限：`user == owner 最佳实践 命名、Gas优化、安全校验 1. 命名：isXXX/hasXXX；\n2. Gas：bool与小类型打包存储；\n3. 校验：require(布尔条件, 报错信息) Solidity 地址类型小结 分类 核心内容 关键说明/示例 基础定义 地址类型作用、两种类型 作用：表示以太坊账户/合约地址（20字节）\n类型：\n1. address：普通地址，不可接收ETH\n2. address payable：可支付地址，可接收ETH 类型转换 普通地址转可支付地址 语法：address payable ap = payable(addr);\n注意：合约地址需实现receive/fallback才能接收ETH 常用操作 1. 地址比较\n2. 查询余额\n3. ETH转账 1. 比较：==/!=，零地址：address(0)\n2. 余额：addr.balance（单位wei，address(this).balance查合约余额）\n3. 转账：推荐to.call{value: msg.value}(\"\")，需校验返回值 重要提示 开发最佳实践与风险防范 1. 校验零地址：require(addr != address(0))\n2. 转账优先用call，避免transfer/send的2300 Gas限制\n3. 防范重入攻击 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 //存钱罐合约 pragma solidity ^0.8.0; contract PiggyBank { address public owner; constructor() { owner = msg.sender; } // 接收 ETH receive() external payable {} // 查询余额 function getBalance() public view returns (uint256) { return address(this).balance; } // 提取 ETH（只有 owner 可以） function withdraw() public { require(msg.sender == owner, \"Only owner can withdraw\"); (bool success, ) = payable(owner).call{value: address(this).balance}(\"\"); require(success, \"Withdraw failed\"); } } Solidity 合约类型总结 核心维度 具体内容 合约类型定义 Solidity 中合约本身是一种数据类型，与 uint、address 等基础类型地位等同，可声明合约类型变量（如 Hello h）。 合约创建方式 使用 new 关键字在合约中部署新合约（如 h = new Hello()），返回新合约实例。 合约交互方式 通过合约类型变量调用目标合约的公开函数（如 h.sayHi()），实现合约间函数调用。 类型转换规则 合约类型 ↔ 地址类型可双向转换：\n1. 合约转地址：address(hello)\n2. 地址转合约：Hello(helloAddr) 核心应用场景 构建复杂合约系统（如工厂合约创建子合约、多合约协作交互）。 关键注意事项 仅能调用目标合约的公开/外部函数；转换地址需确保对应合约已部署且类型匹配。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 pragma solidity ^0.8.0; // 1. 定义 Counter 合约 contract Counter { // 计数状态变量 uint public count; // 增加计数的函数 function increment() public { count += 1; } // 获取当前计数的函数 function getCount() public view returns (uint) { return count; } } // 2. 定义 CounterFactory 工厂合约 contract CounterFactory { // 存储创建的 Counter 合约实例 Counter public counter; // 创建新的 Counter 合约 function createCounter() public returns (address) { counter = new Counter(); return address(counter); } // 调用 Counter 合约的 increment 函数 function incrementCounter() public { // 检查合约是否已创建 require(address(counter) != address(0), \"Counter not created yet\"); counter.increment(); } // 获取 Counter 合约的当前计数值 function getCounterValue() public view returns (uint) { require(address(counter) != address(0), \"Counter not created yet\"); return counter.getCount(); } } Solidity 枚举类型总结 核心维度 具体内容 定义方式 使用 enum 关键字定义，格式：enum 枚举名 { 常量1, 常量2, ... } 数值特性 1. 从 0 开始递增编号\n2. 底层存储为 uint8 类型\n3. 默认值为第一个枚举值 类型转换 1. 枚举 ↔ uint 可相互转换\n2. 整型转枚举需用 require 检查值范围，避免越界 核心操作 1. 支持 ==/!= 比较运算\n2. 通过 type(枚举名).min/max 获取取值范围 典型应用场景 表示有限状态集合：订单状态、任务工作流、合约运行状态等 最佳实践 1. 替代“魔法数字”提升代码可读性\n2. 状态转换时添加合法性验证\n3. 状态变更时触发事件 核心优势 1. 代码可读性/可维护性提升\n2. 限制变量取值范围，减少非法状态 枚举是值类型，赋值时会进行拷贝，而非引用； 枚举定义后不可动态增删常量，适合表示固定的状态集合； 结合结构体、映射可实现复杂的状态管理（如订单/任务系统）。 Solidity 数组总结 核心维度 具体内容 数组类型分类 1. 固定长度数组：T[k]（如 uint[10] tens），长度不可变，仅支持下标赋值；\n2. 动态长度数组：T[]（如 uint[] numbers），长度可动态调整，支持 push/pop。 数据位置要求 数组属于引用类型，声明时需指定位置：\n- storage（状态变量默认）：可动态扩展，支持 push/pop；\n- memory：new 创建后长度固定；\n- calldata：只读，支持数组切片。 初始化方式 1. 直接赋值：uint[] public u = [1,2,3]；\n2. new 关键字：uint[] memory c = new uint(len)（内存数组需指定长度，存储数组可空）。 访问与操作 1. 下标访问：arr[index]（序号从 0 开始），多维数组访问顺序与定义相反（如 uint[][5] x 访问 x[2][1]）；\n2. public 数组自动生成访问器函数（参数为下标），返回整个数组需自定义函数；\n3. 成员：\n- length：只读属性，内存数组长度固定；\n- push()/push(x)：向动态数组末尾添加元素（仅 storage）；\n- pop()：删除末尾元素（仅 storage）。 特殊功能 calldata 数组支持切片：x[start:end]（start 默认 0，end 默认数组长度），常用于提取函数选择器（如 payload[:4]）。 特殊数组类型 1. string：字符数组，不支持 push/pop，无内置字符串操作函数，Gas 效率低；\n2. bytes：动态字节数组，Gas 效率高于 byte[]，支持 push/pop，可通过 bytes(s) 转换 string 后按 UTF-8 编码访问。 开发注意事项 1. 避免遍历大数组：易导致 Gas 超限，建议链下计算/分段处理；\n2. 删除元素：优先用 pop() 或「最后元素替换+pop」减少 Gas 消耗；\n3. 短字节数组：优先用 bytes1-bytes32 降低 Gas。 Solidity 数组分固定/动态长度，核心区别是是否支持 push/pop 及长度能否调整； 数据位置决定数组操作能力（storage 功能最全，calldata 支持切片，memory 长度固定）； string/bytes 作为特殊数组，功能有限且需关注 Gas 效率，大数组遍历需规避 Gas 超限风险。 你希望我根据这份 Solidity 中 string 与 bytes 的学习资料，生成一份结构化的总结表格，清晰梳理各类字节/字符串类型的核心信息。\nSolidity 字节与字符串类型总结 类型分类 具体类型 核心特性 主要使用场景 Gas 效率 核心操作/限制 定长字节数组 bytes1 ~ bytes32 1. 值类型，赋值/传参拷贝\n2. 长度固定不可变\n3. 索引只读访问\n4. 占用空间固定 存储哈希值、ID、固定长度原始字节数据 ⭐⭐⭐⭐⭐ 1. 支持比较/位运算/移位运算\n2. 可通过 .length 获取长度\n3. 索引仅可读，不可修改 动态字节数组 bytes 1. 引用类型（需指定 memory/storage/calldata）\n2. 长度动态可变\n3. 可修改元素 存储任意长度的原始字节数据 ⭐⭐⭐⭐ 1. 支持 push()/pop() 增删元素\n2. 可通过索引修改值\n3. bytes.concat() 拼接\n4. 比 bytes1[] 更省 Gas 动态字节数组 bytes1[] 1. 动态数组，元素为 bytes1\n2. 存储结构松散 几乎不推荐使用（仅兼容旧代码） ⭐⭐ 操作同普通数组，但 Gas 消耗高 字符串类型 string 1. 引用类型，UTF-8 编码\n2. 动态长度\n3. 原生操作受限 存储文本数据（用户名、描述、NFT 的 URI 等） ⭐⭐⭐ 1. 无 length 属性、不支持索引访问\n2. 比较需通过 keccak256 哈希\n3. 复杂操作需先转 bytes 类别 核心内容 常用类型转换 1. string ↔ bytes：直接强转（bytes(str)/string(bytesData)）\n2. string ↔ bytes32：需处理长度（字符串≤32字节），bytes32 转 string 要剔除尾部零字节 Gas 优化建议 1. 固定长度数据优先用 bytes32（如哈希、短ID）\n2. 变长原始数据用 bytes 而非 bytes1[]\n3. 长文本数据链下存储（IPFS），合约仅存哈希/URI\n4. 短字符串（≤32字节）可考虑用 bytes32 替代 string 类型选择核心：固定长度数据选 bytes1~bytes32（优先 bytes32），变长原始字节选 bytes，文本数据选 string，避免使用 bytes1[]。 操作核心：string 的复杂操作（长度、索引、修改）需先转为 bytes，字符串比较需通过哈希值而非直接 ==。 Gas 优化核心：优先选择存储更紧凑的类型（bytes32 \u003e bytes \u003e string \u003e bytes1[]），长文本数据尽量链下存储。 Solidity 结构体总结 类别 具体说明 示例/注意事项 结构体定义 使用 struct 关键字定义自定义复合类型，将多个不同类型数据组合成新类型 struct Person { address account; bool gender; uint8 age; } 成员类型规则 1. 支持基本类型、数组、映射、其他结构体作为成员\n2. 不能直接包含自身作为成员\n3. 可包含自身类型的数组/映射（不推荐） 错误示例：struct Person { Person child; }（无法编译）\n合法示例：struct Person { Person[] childs; } 赋值方式 1. 仅声明（使用默认值）\n2. 按成员顺序赋值\n3. 具名方式赋值\n4. 逐个更新成员 具名赋值示例：Person({account: address(0x0), gender: false, age: 18}) 访问器函数 public 结构体状态变量会自动生成访问器函数，无参数，返回包含所有成员的元组 生成的函数示例：function person() external view returns (address, bool, uint8) { ... } 存储特性 结构体成员默认连续分配存储槽；变长成员（数组/映射）单独分配存储槽，仅留指向位置 解释了“可包含自身数组/映射，但不能直接包含自身”的底层原因 Solidity 映射知识点总结表格 核心知识点 具体内容 映射定义方式 键值对存储结构，格式：mapping(KeyType =\u003e ValueType)，功能类似 Java Map/Python Dict，常用于存储余额、用户等级等键值数据 存储位置限制 仅能保存在 storage（状态变量默认），不支持 memory 修饰 键/值类型限制 键：仅支持内置值类型、bytes、string、合约/枚举，不支持映射、变长数组、结构体等复杂类型\n值：无类型限制，可是任意类型（包括嵌套映射） 核心特性 1. 无长度属性，无法直接获取长度\n2. 无键/值集合，无法直接迭代\n3. 不存在的键返回对应值类型默认值（如 uint 为 0，bool 为 false） 嵌套映射 支持嵌套（值类型为另一个映射），示例：mapping(address =\u003e mapping(address =\u003e uint)) tokenBalances 访问器函数 public 映射状态变量会生成访问器函数，参数为键类型，返回值类型；嵌套映射的访问器会接收多层键参数 可迭代映射实现方式 方式1：维护键的数组（实现简单但Gas成本较高）\n方式2：通过链表（推荐，可实现O(1)复杂度），用mapping存储下一个元素地址 数组 vs 映射 数组：适合迭代场景，Gas消耗随长度增加变大，不宜过大\n映射：适合已知键快速取值，Gas消耗更优，不支持直接迭代 Solidity 函数总结 模块 核心分类/概念 关键细节 示例/注意事项 函数基本语法 完整结构 function 函数名(参数类型 参数名) 可见性 状态可变性 [修饰器] returns (返回值类型) { 函数体 } 严格遵循语法结构，提升代码可读性 函数可见性 public 当前合约、子合约、外部均可调用；状态变量自动生成同名 getter 函数 内外部都需要调用的函数 external 仅外部可调用；内部需通过 this 调用 只需外部调用的函数（更省 gas） internal 当前合约、子合约可调用；外部不可调用 合约内部/继承的辅助函数（命名建议加前缀 _） private 仅当前合约可调用；子合约不可访问 当前合约私有实现细节 选择原则 优先最严格可见性（private→internal→external→public），减少攻击面 避免不必要的 public，辅助函数用 internal/private 状态可变性 无修饰符 可读写状态，不可接收 ETH 普通状态修改（如赋值状态变量） view 仅读取状态，不可修改 查询数据（如读取状态变量），外部调用免费 pure 不读写状态，仅依赖入参计算 纯数学运算（如加法、乘法） payable 可读写状态，可接收 ETH 转账、存款等需要接收 ETH 的场景 选择原则 不修改状态的函数必须标记 view/pure，编译器强制校验 避免省略状态可变性修饰符，提升安全性和可读性 函数调用方式 内部调用 直接用函数名调用；同一执行上下文；msg.sender/msg.value 不变；gas 消耗低 合约内部函数间调用，优先使用 外部调用 通过 this/合约实例调用；新执行上下文；msg.sender 可能变化；gas 消耗高 调用外部合约函数，需注意重入攻击风险 参数数据位置 memory 临时存储，函数调用后释放；可读写 函数参数/局部变量（如字符串、数组） calldata 只读，外部函数参数专用；最省 gas external 函数的数组/字符串参数 storage 永久存储，引用状态变量；gas 消耗高 内部函数中引用状态变量（如结构体、数组） 函数重载 规则 同名函数，参数列表（个数/类型）不同；仅返回值不同无法重载 实现同一功能的多参数版本（如两数相加/三数相加） 特殊函数 constructor 合约部署时执行一次；可标记 payable（部署时接收 ETH） 初始化状态变量（如设置合约 owner、token 名称） receive() 接收纯 ETH 转账时触发；必须 external payable，无参数无返回值 处理用户直接转账 ETH 的逻辑 fallback() 调用不存在的函数/带数据的转账时触发；必须 external payable 处理未知调用，兜底逻辑 多返回值 语法 支持多值返回；可命名返回值；支持解构赋值（忽略部分值用 ,） 一次性返回多个相关数据（如数字、布尔值、字符串） ","wordCount":"1064","inLanguage":"en","image":"https://flash122u.github.io/images/avatar.png","datePublished":"2026-01-12T10:30:00+08:00","dateModified":"2026-01-12T10:30:00+08:00","author":{"@type":"Person","name":"flash122u"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://flash122u.github.io/posts/learn_solidity_2/"},"publisher":{"@type":"Organization","name":"flash122u's blog","logo":{"@type":"ImageObject","url":"https://flash122u.github.io/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://flash122u.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://flash122u.github.io/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://flash122u.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://flash122u.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://flash122u.github.io/index.xml title=RSS><span>RSS</span></a></li><li><a href=https://flash122u.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://flash122u.github.io/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://flash122u.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://flash122u.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Solidity 学习记录_2_数据类型</h1><div class=post-description>记录 Solidity 学习 2</div><div class=post-meta><span title='2026-01-12 10:30:00 +0800 +0800'>January 12, 2026</span>&nbsp;·&nbsp;<span>5 min</span>&nbsp;·&nbsp;<span>1064 words</span>&nbsp;·&nbsp;<span>flash122u</span>&nbsp;|&nbsp;<span>
<a href=https://github.com/flash122u/hugo-blog-source rel="noopener noreferrer edit" target=_blank>edit</a></span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#solidity-数据类型小结>Solidity 数据类型小结</a></li><li><a href=#solidity-整型uint与int小结>Solidity 整型（uint与int）小结</a></li><li><a href=#solidity-布尔类型小结>Solidity 布尔类型小结</a></li><li><a href=#solidity-地址类型小结>Solidity 地址类型小结</a></li><li><a href=#solidity-合约类型总结>Solidity 合约类型总结</a></li><li><a href=#solidity-枚举类型总结>Solidity 枚举类型总结</a></li><li><a href=#solidity-数组总结>Solidity 数组总结</a></li><li><a href=#solidity-字节与字符串类型总结>Solidity 字节与字符串类型总结</a></li><li><a href=#solidity-结构体总结>Solidity 结构体总结</a></li><li><a href=#solidity-映射知识点总结表格>Solidity 映射知识点总结表格</a></li><li><a href=#solidity-函数总结>Solidity 函数总结</a></li></ul></nav></div></details></div><div class=post-content><h2 id=solidity-数据类型小结>Solidity 数据类型小结<a hidden class=anchor aria-hidden=true href=#solidity-数据类型小结>#</a></h2><table><thead><tr><th><strong>分类</strong></th><th><strong>核心内容</strong></th><th><strong>关键特性</strong></th></tr></thead><tbody><tr><td><strong>类型体系</strong></td><td>分为<strong>值类型</strong>、<strong>引用类型</strong>、<strong>映射类型</strong>三大类</td><td>Solidity 是<strong>静态类型语言</strong>，变量类型编译时确定</td></tr><tr><td><strong>值类型</strong></td><td>包含布尔、整型（uint/int）、地址、定长字节数组、枚举、函数类型等</td><td>1. 赋值/传参时<strong>值拷贝</strong>，修改副本不影响原变量<br>2. 数据占用 ≤32 字节<br>3. 示例：<code>uint a=10; uint b=a; b=20;</code> → <code>a</code> 仍为 10</td></tr><tr><td><strong>引用类型</strong></td><td>包含数组、结构体、string/bytes（动态字节数组）、合约</td><td>1. 数据占用通常 >32 字节，支持<strong>引用传递</strong>减少拷贝开销<br>2. 必须显式指定<strong>数据位置</strong>（memory/storage/calldata）<br>3. 赋值规则：<br>- 不同位置赋值 → 拷贝副本<br>- 相同位置赋值 → 创建引用（修改新变量会影响原变量）</td></tr><tr><td><strong>数据位置（引用类型专属）</strong></td><td>4 种位置（transient 不支持引用类型）</td><td></td></tr><tr><td></td><td><strong>storage</strong></td><td>存储状态变量，永久保存在区块链，Gas 消耗最高</td></tr><tr><td></td><td><strong>memory</strong></td><td>函数内临时存储，函数执行后释放，Gas 中等</td></tr><tr><td></td><td><strong>calldata</strong></td><td>存储 external 函数参数，只读不可修改，Gas 消耗最低</td></tr><tr><td></td><td><strong>transient</strong></td><td>单次交易内有效，不支持引用类型定义</td></tr><tr><td><strong>映射类型</strong></td><td>键值对结构（<code>mapping(KeyType => ValueType)</code>）</td><td>1. 类似字典/哈希表，仅支持作为<strong>状态变量</strong>（storage）<br>2. 详细用法需结合后续数据结构章节学习</td></tr></tbody></table><ol><li><p><strong>值类型 vs 引用类型</strong></p><ul><li>值类型：拷贝传递，独立存储，适合简单数据。</li><li>引用类型：需指定数据位置，支持引用传递，适合复杂数据（数组、结构体等），可节省 Gas。</li></ul></li><li><p><strong>数据位置选择原则</strong></p><ul><li>状态变量默认 <code>storage</code>；</li><li>函数内临时变量用 <code>memory</code>；</li><li><code>external</code> 函数参数优先用 <code>calldata</code>；</li><li>交易内临时共享数据用 <code>transient</code>（仅限值类型）。</li></ul></li><li><p><strong>赋值行为关键规则</strong></p><blockquote><p>不同位置赋值→拷贝，相同位置赋值→引用。</p></blockquote></li></ol><h2 id=solidity-整型uint与int小结>Solidity 整型（uint与int）小结<a hidden class=anchor aria-hidden=true href=#solidity-整型uint与int小结>#</a></h2><table><thead><tr><th><strong>类别</strong></th><th><strong>核心内容</strong></th></tr></thead><tbody><tr><td><strong>类型定义</strong></td><td>1. 两类整型：<code>uint</code>（无符号整数，非负）、<code>int</code>（有符号整数，可正负）<br>2. 位数范围：<code>uint8</code>-<code>uint256</code>、<code>int8</code>-<code>int256</code>，<strong>8位步进</strong><br>3. 默认类型：<code>uint</code>等价<code>uint256</code>，<code>int</code>等价<code>int256</code></td></tr><tr><td><strong>取值范围</strong></td><td>1. <code>uintN</code>：<code>0 ~ 2^N - 1</code>（如<code>uint8</code>：<code>0~255</code>）<br>2. <code>intN</code>：<code>-2^(N-1) ~ 2^(N-1) - 1</code>（如<code>int8</code>：<code>-128~127</code>）<br>3. 默认值：所有整型变量未赋值时默认<strong>0</strong></td></tr><tr><td><strong>运算规则</strong></td><td>1. <strong>支持运算符</strong>：比较（<code>></code>/<code>&lt;</code>/<code>==</code>等）、算术（<code>+</code>/<code>-</code>/<code>*</code>/<code>/</code>/<code>%</code>/<code>**</code>）、位运算（<code>&</code>/`</td></tr><tr><td><strong>Gas 优化</strong></td><td>确定运算无溢出时，使用<code>unchecked</code>模式可<strong>节省 Gas</strong>（单次约省0.26%，循环场景效果显著）</td></tr><tr><td><strong>使用场景选择</strong></td><td>1. <strong>优先用 uint</strong>：代币余额、数组索引、时间戳、计数器等<strong>非负场景</strong><br>2. <strong>使用 int</strong>：温度、价格波动、数值差值等<strong>需表示正负的场景</strong></td></tr><tr><td><strong>常见陷阱&避坑方案</strong></td><td>1. <strong>无符号下溢</strong>：<code>uint x=0; x-1</code>会回退 → 先判断<code>x>0</code>再减法<br>2. <strong>除法截断</strong>：需精度时放大分子（如<code>(5*1e18)/2</code>）<br>3. <strong>类型转换截断</strong>：大类型转小类型前，用<code>require(val &lt;= type(uint8).max)</code>校验<br>4. <strong>跨类型比较</strong>：<code>int</code>与<code>uint</code>直接比较易出错 → 统一转换为相同类型再比较</td></tr><tr><td><strong>进阶技巧</strong></td><td>用<code>type(X).min</code>/<code>type(X).max</code>获取整型<code>X</code>的最值（如<code>type(uint8).max=255</code>）</td></tr></tbody></table><h2 id=solidity-布尔类型小结>Solidity 布尔类型小结<a hidden class=anchor aria-hidden=true href=#solidity-布尔类型小结>#</a></h2><table><thead><tr><th>分类</th><th>核心内容</th><th>关键说明/示例</th></tr></thead><tbody><tr><td>基础特性</td><td>关键字、取值、默认值</td><td>关键字：<code>bool</code>；取值：<code>true</code>/<code>false</code>；默认值：<code>false</code></td></tr><tr><td>核心运算符</td><td>逻辑运算符：<code>&&</code>（与）、`</td><td></td></tr><tr><td>短路求值</td><td>规则、优化技巧</td><td>规则：<code>&&</code>左false/`</td></tr><tr><td>典型应用</td><td>权限控制、状态管理、功能开关、条件判断</td><td>示例：<br>1. 权限：`user == owner</td></tr><tr><td>最佳实践</td><td>命名、Gas优化、安全校验</td><td>1. 命名：<code>isXXX</code>/<code>hasXXX</code>；<br>2. Gas：bool与小类型打包存储；<br>3. 校验：<code>require(布尔条件, 报错信息)</code></td></tr></tbody></table><h2 id=solidity-地址类型小结>Solidity 地址类型小结<a hidden class=anchor aria-hidden=true href=#solidity-地址类型小结>#</a></h2><table><thead><tr><th>分类</th><th>核心内容</th><th>关键说明/示例</th></tr></thead><tbody><tr><td>基础定义</td><td>地址类型作用、两种类型</td><td>作用：表示以太坊账户/合约地址（20字节）<br>类型：<br>1. <code>address</code>：普通地址，不可接收ETH<br>2. <code>address payable</code>：可支付地址，可接收ETH</td></tr><tr><td>类型转换</td><td>普通地址转可支付地址</td><td>语法：<code>address payable ap = payable(addr);</code><br>注意：合约地址需实现<code>receive</code>/<code>fallback</code>才能接收ETH</td></tr><tr><td>常用操作</td><td>1. 地址比较<br>2. 查询余额<br>3. ETH转账</td><td>1. 比较：<code>==</code>/<code>!=</code>，零地址：<code>address(0)</code><br>2. 余额：<code>addr.balance</code>（单位wei，<code>address(this).balance</code>查合约余额）<br>3. 转账：推荐<code>to.call{value: msg.value}("")</code>，需校验返回值</td></tr><tr><td>重要提示</td><td>开发最佳实践与风险防范</td><td>1. 校验零地址：<code>require(addr != address(0))</code><br>2. 转账优先用<code>call</code>，避免<code>transfer</code>/<code>send</code>的2300 Gas限制<br>3. 防范重入攻击</td></tr></tbody></table><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-solidity data-lang=solidity><span class=line><span class=cl><span class=c1>//存钱罐合约
</span></span></span><span class=line><span class=cl><span class=k>pragma solidity</span> <span class=o>^</span><span class=mi>0</span><span class=p>.</span><span class=mi>8</span><span class=p>.</span><span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>contract</span> <span class=nc>PiggyBank</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>address</span> <span class=k>public</span> <span class=n>owner</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>constructor</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>owner</span> <span class=o>=</span> <span class=nb>msg</span><span class=p>.</span><span class=nb>sender</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 接收 ETH
</span></span></span><span class=line><span class=cl>    <span class=n>receive</span><span class=p>()</span> <span class=k>external</span> <span class=k>payable</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 查询余额
</span></span></span><span class=line><span class=cl>    <span class=kd>function</span> <span class=nf>getBalance</span><span class=p>()</span> <span class=k>public</span> <span class=k>view</span> <span class=k>returns</span> <span class=p>(</span><span class=kt>uint256</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kt>address</span><span class=p>(</span><span class=nb>this</span><span class=p>).</span><span class=nb>balance</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 提取 ETH（只有 owner 可以）
</span></span></span><span class=line><span class=cl>    <span class=kd>function</span> <span class=nf>withdraw</span><span class=p>()</span> <span class=k>public</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nb>require</span><span class=p>(</span><span class=nb>msg</span><span class=p>.</span><span class=nb>sender</span> <span class=o>==</span> <span class=n>owner</span><span class=p>,</span> <span class=s>&#34;Only owner can withdraw&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=kt>bool</span> <span class=n>success</span><span class=p>,</span> <span class=p>)</span> <span class=o>=</span> <span class=k>payable</span><span class=p>(</span><span class=n>owner</span><span class=p>).</span><span class=nb>call</span><span class=p>{</span><span class=nb>value</span><span class=o>:</span> <span class=kt>address</span><span class=p>(</span><span class=nb>this</span><span class=p>).</span><span class=nb>balance</span><span class=p>}(</span><span class=s>&#34;&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nb>require</span><span class=p>(</span><span class=n>success</span><span class=p>,</span> <span class=s>&#34;Withdraw failed&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=solidity-合约类型总结>Solidity 合约类型总结<a hidden class=anchor aria-hidden=true href=#solidity-合约类型总结>#</a></h2><table><thead><tr><th><strong>核心维度</strong></th><th><strong>具体内容</strong></th></tr></thead><tbody><tr><td>合约类型定义</td><td>Solidity 中合约本身是一种数据类型，与 <code>uint</code>、<code>address</code> 等基础类型地位等同，可声明合约类型变量（如 <code>Hello h</code>）。</td></tr><tr><td>合约创建方式</td><td>使用 <code>new</code> 关键字在合约中部署新合约（如 <code>h = new Hello()</code>），返回新合约实例。</td></tr><tr><td>合约交互方式</td><td>通过合约类型变量调用目标合约的公开函数（如 <code>h.sayHi()</code>），实现合约间函数调用。</td></tr><tr><td>类型转换规则</td><td>合约类型 ↔ 地址类型可双向转换：<br>1. 合约转地址：<code>address(hello)</code><br>2. 地址转合约：<code>Hello(helloAddr)</code></td></tr><tr><td>核心应用场景</td><td>构建复杂合约系统（如工厂合约创建子合约、多合约协作交互）。</td></tr><tr><td>关键注意事项</td><td>仅能调用目标合约的<strong>公开/外部函数</strong>；转换地址需确保对应合约已部署且类型匹配。</td></tr></tbody></table><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-solidity data-lang=solidity><span class=line><span class=cl><span class=k>pragma solidity</span> <span class=o>^</span><span class=mi>0</span><span class=p>.</span><span class=mi>8</span><span class=p>.</span><span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 1. 定义 Counter 合约
</span></span></span><span class=line><span class=cl><span class=kd>contract</span> <span class=nc>Counter</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 计数状态变量
</span></span></span><span class=line><span class=cl>    <span class=kt>uint</span> <span class=k>public</span> <span class=n>count</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 增加计数的函数
</span></span></span><span class=line><span class=cl>    <span class=kd>function</span> <span class=nf>increment</span><span class=p>()</span> <span class=k>public</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>count</span> <span class=o>+=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 获取当前计数的函数
</span></span></span><span class=line><span class=cl>    <span class=kd>function</span> <span class=nf>getCount</span><span class=p>()</span> <span class=k>public</span> <span class=k>view</span> <span class=k>returns</span> <span class=p>(</span><span class=kt>uint</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>count</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 2. 定义 CounterFactory 工厂合约
</span></span></span><span class=line><span class=cl><span class=kd>contract</span> <span class=nc>CounterFactory</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 存储创建的 Counter 合约实例
</span></span></span><span class=line><span class=cl>    <span class=n>Counter</span> <span class=k>public</span> <span class=n>counter</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 创建新的 Counter 合约
</span></span></span><span class=line><span class=cl>    <span class=kd>function</span> <span class=nf>createCounter</span><span class=p>()</span> <span class=k>public</span> <span class=k>returns</span> <span class=p>(</span><span class=kt>address</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>counter</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Counter</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kt>address</span><span class=p>(</span><span class=n>counter</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 调用 Counter 合约的 increment 函数
</span></span></span><span class=line><span class=cl>    <span class=kd>function</span> <span class=nf>incrementCounter</span><span class=p>()</span> <span class=k>public</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 检查合约是否已创建
</span></span></span><span class=line><span class=cl>        <span class=nb>require</span><span class=p>(</span><span class=kt>address</span><span class=p>(</span><span class=n>counter</span><span class=p>)</span> <span class=o>!=</span> <span class=kt>address</span><span class=p>(</span><span class=mi>0</span><span class=p>),</span> <span class=s>&#34;Counter not created yet&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>counter</span><span class=p>.</span><span class=n>increment</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 获取 Counter 合约的当前计数值
</span></span></span><span class=line><span class=cl>    <span class=kd>function</span> <span class=nf>getCounterValue</span><span class=p>()</span> <span class=k>public</span> <span class=k>view</span> <span class=k>returns</span> <span class=p>(</span><span class=kt>uint</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nb>require</span><span class=p>(</span><span class=kt>address</span><span class=p>(</span><span class=n>counter</span><span class=p>)</span> <span class=o>!=</span> <span class=kt>address</span><span class=p>(</span><span class=mi>0</span><span class=p>),</span> <span class=s>&#34;Counter not created yet&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>counter</span><span class=p>.</span><span class=n>getCount</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=solidity-枚举类型总结>Solidity 枚举类型总结<a hidden class=anchor aria-hidden=true href=#solidity-枚举类型总结>#</a></h2><table><thead><tr><th><strong>核心维度</strong></th><th><strong>具体内容</strong></th></tr></thead><tbody><tr><td><strong>定义方式</strong></td><td>使用 <code>enum</code> 关键字定义，格式：<code>enum 枚举名 { 常量1, 常量2, ... }</code></td></tr><tr><td><strong>数值特性</strong></td><td>1. 从 0 开始递增编号<br>2. 底层存储为 <code>uint8</code> 类型<br>3. 默认值为第一个枚举值</td></tr><tr><td><strong>类型转换</strong></td><td>1. 枚举 ↔ uint 可相互转换<br>2. 整型转枚举需用 <code>require</code> 检查值范围，避免越界</td></tr><tr><td><strong>核心操作</strong></td><td>1. 支持 <code>==</code>/<code>!=</code> 比较运算<br>2. 通过 <code>type(枚举名).min/max</code> 获取取值范围</td></tr><tr><td><strong>典型应用场景</strong></td><td>表示有限状态集合：订单状态、任务工作流、合约运行状态等</td></tr><tr><td><strong>最佳实践</strong></td><td>1. 替代“魔法数字”提升代码可读性<br>2. 状态转换时添加合法性验证<br>3. 状态变更时触发事件</td></tr><tr><td><strong>核心优势</strong></td><td>1. 代码可读性/可维护性提升<br>2. 限制变量取值范围，减少非法状态</td></tr></tbody></table><ul><li>枚举是<strong>值类型</strong>，赋值时会进行拷贝，而非引用；</li><li>枚举定义后不可动态增删常量，适合表示固定的状态集合；</li><li>结合结构体、映射可实现复杂的状态管理（如订单/任务系统）。</li></ul><h2 id=solidity-数组总结>Solidity 数组总结<a hidden class=anchor aria-hidden=true href=#solidity-数组总结>#</a></h2><table><thead><tr><th><strong>核心维度</strong></th><th><strong>具体内容</strong></th></tr></thead><tbody><tr><td>数组类型分类</td><td>1. 固定长度数组：<code>T[k]</code>（如 <code>uint[10] tens</code>），长度不可变，仅支持下标赋值；<br>2. 动态长度数组：<code>T[]</code>（如 <code>uint[] numbers</code>），长度可动态调整，支持 <code>push/pop</code>。</td></tr><tr><td>数据位置要求</td><td>数组属于引用类型，声明时需指定位置：<br>- storage（状态变量默认）：可动态扩展，支持 <code>push/pop</code>；<br>- memory：<code>new</code> 创建后长度固定；<br>- calldata：只读，支持数组切片。</td></tr><tr><td>初始化方式</td><td>1. 直接赋值：<code>uint[] public u = [1,2,3]</code>；<br>2. <code>new</code> 关键字：<code>uint[] memory c = new uint(len)</code>（内存数组需指定长度，存储数组可空）。</td></tr><tr><td>访问与操作</td><td>1. 下标访问：<code>arr[index]</code>（序号从 0 开始），多维数组访问顺序与定义相反（如 <code>uint[][5] x</code> 访问 <code>x[2][1]</code>）；<br>2. public 数组自动生成访问器函数（参数为下标），返回整个数组需自定义函数；<br>3. 成员：<br>- <code>length</code>：只读属性，内存数组长度固定；<br>- <code>push()</code>/<code>push(x)</code>：向动态数组末尾添加元素（仅 storage）；<br>- <code>pop()</code>：删除末尾元素（仅 storage）。</td></tr><tr><td>特殊功能</td><td>calldata 数组支持切片：<code>x[start:end]</code>（start 默认 0，end 默认数组长度），常用于提取函数选择器（如 <code>payload[:4]</code>）。</td></tr><tr><td>特殊数组类型</td><td>1. string：字符数组，不支持 <code>push/pop</code>，无内置字符串操作函数，Gas 效率低；<br>2. bytes：动态字节数组，Gas 效率高于 <code>byte[]</code>，支持 <code>push/pop</code>，可通过 <code>bytes(s)</code> 转换 string 后按 UTF-8 编码访问。</td></tr><tr><td>开发注意事项</td><td>1. 避免遍历大数组：易导致 Gas 超限，建议链下计算/分段处理；<br>2. 删除元素：优先用 <code>pop()</code> 或「最后元素替换+pop」减少 Gas 消耗；<br>3. 短字节数组：优先用 <code>bytes1-bytes32</code> 降低 Gas。</td></tr></tbody></table><ol><li>Solidity 数组分固定/动态长度，核心区别是是否支持 <code>push/pop</code> 及长度能否调整；</li><li>数据位置决定数组操作能力（storage 功能最全，calldata 支持切片，memory 长度固定）；</li><li>string/bytes 作为特殊数组，功能有限且需关注 Gas 效率，大数组遍历需规避 Gas 超限风险。</li></ol><p>你希望我根据这份 Solidity 中 string 与 bytes 的学习资料，生成一份结构化的总结表格，清晰梳理各类字节/字符串类型的核心信息。</p><h2 id=solidity-字节与字符串类型总结>Solidity 字节与字符串类型总结<a hidden class=anchor aria-hidden=true href=#solidity-字节与字符串类型总结>#</a></h2><table><thead><tr><th>类型分类</th><th>具体类型</th><th>核心特性</th><th>主要使用场景</th><th>Gas 效率</th><th>核心操作/限制</th></tr></thead><tbody><tr><td>定长字节数组</td><td>bytes1 ~ bytes32</td><td>1. 值类型，赋值/传参拷贝<br>2. 长度固定不可变<br>3. 索引只读访问<br>4. 占用空间固定</td><td>存储哈希值、ID、固定长度原始字节数据</td><td>⭐⭐⭐⭐⭐</td><td>1. 支持比较/位运算/移位运算<br>2. 可通过 <code>.length</code> 获取长度<br>3. 索引仅可读，不可修改</td></tr><tr><td>动态字节数组</td><td>bytes</td><td>1. 引用类型（需指定 memory/storage/calldata）<br>2. 长度动态可变<br>3. 可修改元素</td><td>存储任意长度的原始字节数据</td><td>⭐⭐⭐⭐</td><td>1. 支持 push()/pop() 增删元素<br>2. 可通过索引修改值<br>3. bytes.concat() 拼接<br>4. 比 bytes1[] 更省 Gas</td></tr><tr><td>动态字节数组</td><td>bytes1[]</td><td>1. 动态数组，元素为 bytes1<br>2. 存储结构松散</td><td>几乎不推荐使用（仅兼容旧代码）</td><td>⭐⭐</td><td>操作同普通数组，但 Gas 消耗高</td></tr><tr><td>字符串类型</td><td>string</td><td>1. 引用类型，UTF-8 编码<br>2. 动态长度<br>3. 原生操作受限</td><td>存储文本数据（用户名、描述、NFT 的 URI 等）</td><td>⭐⭐⭐</td><td>1. 无 length 属性、不支持索引访问<br>2. 比较需通过 keccak256 哈希<br>3. 复杂操作需先转 bytes</td></tr></tbody></table><table><thead><tr><th>类别</th><th>核心内容</th></tr></thead><tbody><tr><td>常用类型转换</td><td>1. string ↔ bytes：直接强转（bytes(str)/string(bytesData)）<br>2. string ↔ bytes32：需处理长度（字符串≤32字节），bytes32 转 string 要剔除尾部零字节</td></tr><tr><td>Gas 优化建议</td><td>1. 固定长度数据优先用 bytes32（如哈希、短ID）<br>2. 变长原始数据用 bytes 而非 bytes1[]<br>3. 长文本数据链下存储（IPFS），合约仅存哈希/URI<br>4. 短字符串（≤32字节）可考虑用 bytes32 替代 string</td></tr></tbody></table><ol><li><strong>类型选择核心</strong>：固定长度数据选 <code>bytes1~bytes32</code>（优先 bytes32），变长原始字节选 <code>bytes</code>，文本数据选 <code>string</code>，避免使用 <code>bytes1[]</code>。</li><li><strong>操作核心</strong>：<code>string</code> 的复杂操作（长度、索引、修改）需先转为 <code>bytes</code>，字符串比较需通过哈希值而非直接 <code>==</code>。</li><li><strong>Gas 优化核心</strong>：优先选择存储更紧凑的类型（bytes32 > bytes > string > bytes1[]），长文本数据尽量链下存储。</li></ol><h2 id=solidity-结构体总结>Solidity 结构体总结<a hidden class=anchor aria-hidden=true href=#solidity-结构体总结>#</a></h2><table><thead><tr><th>类别</th><th>具体说明</th><th>示例/注意事项</th></tr></thead><tbody><tr><td>结构体定义</td><td>使用 <code>struct</code> 关键字定义自定义复合类型，将多个不同类型数据组合成新类型</td><td><code>struct Person { address account; bool gender; uint8 age; }</code></td></tr><tr><td>成员类型规则</td><td>1. 支持基本类型、数组、映射、其他结构体作为成员<br>2. 不能直接包含自身作为成员<br>3. 可包含自身类型的数组/映射（不推荐）</td><td>错误示例：<code>struct Person { Person child; }</code>（无法编译）<br>合法示例：<code>struct Person { Person[] childs; }</code></td></tr><tr><td>赋值方式</td><td>1. 仅声明（使用默认值）<br>2. 按成员顺序赋值<br>3. 具名方式赋值<br>4. 逐个更新成员</td><td>具名赋值示例：<code>Person({account: address(0x0), gender: false, age: 18})</code></td></tr><tr><td>访问器函数</td><td><code>public</code> 结构体状态变量会自动生成访问器函数，无参数，返回包含所有成员的元组</td><td>生成的函数示例：<code>function person() external view returns (address, bool, uint8) { ... }</code></td></tr><tr><td>存储特性</td><td>结构体成员默认连续分配存储槽；变长成员（数组/映射）单独分配存储槽，仅留指向位置</td><td>解释了“可包含自身数组/映射，但不能直接包含自身”的底层原因</td></tr></tbody></table><h2 id=solidity-映射知识点总结表格>Solidity 映射知识点总结表格<a hidden class=anchor aria-hidden=true href=#solidity-映射知识点总结表格>#</a></h2><table><thead><tr><th>核心知识点</th><th>具体内容</th></tr></thead><tbody><tr><td>映射定义方式</td><td>键值对存储结构，格式：<code>mapping(KeyType => ValueType)</code>，功能类似 Java Map/Python Dict，常用于存储余额、用户等级等键值数据</td></tr><tr><td>存储位置限制</td><td>仅能保存在 <code>storage</code>（状态变量默认），不支持 <code>memory</code> 修饰</td></tr><tr><td>键/值类型限制</td><td>键：仅支持内置值类型、bytes、string、合约/枚举，不支持映射、变长数组、结构体等复杂类型<br>值：无类型限制，可是任意类型（包括嵌套映射）</td></tr><tr><td>核心特性</td><td>1. 无长度属性，无法直接获取长度<br>2. 无键/值集合，无法直接迭代<br>3. 不存在的键返回对应值类型默认值（如 uint 为 0，bool 为 false）</td></tr><tr><td>嵌套映射</td><td>支持嵌套（值类型为另一个映射），示例：<code>mapping(address => mapping(address => uint)) tokenBalances</code></td></tr><tr><td>访问器函数</td><td><code>public</code> 映射状态变量会生成访问器函数，参数为键类型，返回值类型；嵌套映射的访问器会接收多层键参数</td></tr><tr><td>可迭代映射实现方式</td><td>方式1：维护键的数组（实现简单但Gas成本较高）<br>方式2：通过链表（推荐，可实现O(1)复杂度），用mapping存储下一个元素地址</td></tr><tr><td>数组 vs 映射</td><td>数组：适合迭代场景，Gas消耗随长度增加变大，不宜过大<br>映射：适合已知键快速取值，Gas消耗更优，不支持直接迭代</td></tr></tbody></table><h2 id=solidity-函数总结>Solidity 函数总结<a hidden class=anchor aria-hidden=true href=#solidity-函数总结>#</a></h2><table><thead><tr><th><strong>模块</strong></th><th><strong>核心分类/概念</strong></th><th><strong>关键细节</strong></th><th>示例/注意事项</th></tr></thead><tbody><tr><td><strong>函数基本语法</strong></td><td>完整结构</td><td><code>function 函数名(参数类型 参数名) 可见性 状态可变性 [修饰器] returns (返回值类型) { 函数体 }</code></td><td>严格遵循语法结构，提升代码可读性</td></tr><tr><td><strong>函数可见性</strong></td><td><code>public</code></td><td>当前合约、子合约、外部均可调用；状态变量自动生成同名 getter 函数</td><td>内外部都需要调用的函数</td></tr><tr><td></td><td><code>external</code></td><td>仅外部可调用；内部需通过 <code>this</code> 调用</td><td>只需外部调用的函数（更省 gas）</td></tr><tr><td></td><td><code>internal</code></td><td>当前合约、子合约可调用；外部不可调用</td><td>合约内部/继承的辅助函数（命名建议加前缀 <code>_</code>）</td></tr><tr><td></td><td><code>private</code></td><td>仅当前合约可调用；子合约不可访问</td><td>当前合约私有实现细节</td></tr><tr><td></td><td>选择原则</td><td>优先最严格可见性（<code>private</code>→<code>internal</code>→<code>external</code>→<code>public</code>），减少攻击面</td><td>避免不必要的 <code>public</code>，辅助函数用 <code>internal</code>/<code>private</code></td></tr><tr><td><strong>状态可变性</strong></td><td>无修饰符</td><td>可读写状态，<strong>不可接收 ETH</strong></td><td>普通状态修改（如赋值状态变量）</td></tr><tr><td></td><td><code>view</code></td><td>仅读取状态，不可修改</td><td>查询数据（如读取状态变量），外部调用免费</td></tr><tr><td></td><td><code>pure</code></td><td>不读写状态，仅依赖入参计算</td><td>纯数学运算（如加法、乘法）</td></tr><tr><td></td><td><code>payable</code></td><td>可读写状态，<strong>可接收 ETH</strong></td><td>转账、存款等需要接收 ETH 的场景</td></tr><tr><td></td><td>选择原则</td><td>不修改状态的函数必须标记 <code>view</code>/<code>pure</code>，编译器强制校验</td><td>避免省略状态可变性修饰符，提升安全性和可读性</td></tr><tr><td><strong>函数调用方式</strong></td><td>内部调用</td><td>直接用函数名调用；同一执行上下文；<code>msg.sender</code>/<code>msg.value</code> 不变；gas 消耗低</td><td>合约内部函数间调用，优先使用</td></tr><tr><td></td><td>外部调用</td><td>通过 <code>this</code>/合约实例调用；新执行上下文；<code>msg.sender</code> 可能变化；gas 消耗高</td><td>调用外部合约函数，需注意重入攻击风险</td></tr><tr><td><strong>参数数据位置</strong></td><td><code>memory</code></td><td>临时存储，函数调用后释放；可读写</td><td>函数参数/局部变量（如字符串、数组）</td></tr><tr><td></td><td><code>calldata</code></td><td>只读，外部函数参数专用；最省 gas</td><td><code>external</code> 函数的数组/字符串参数</td></tr><tr><td></td><td><code>storage</code></td><td>永久存储，引用状态变量；gas 消耗高</td><td>内部函数中引用状态变量（如结构体、数组）</td></tr><tr><td><strong>函数重载</strong></td><td>规则</td><td>同名函数，<strong>参数列表（个数/类型）不同</strong>；仅返回值不同无法重载</td><td>实现同一功能的多参数版本（如两数相加/三数相加）</td></tr><tr><td><strong>特殊函数</strong></td><td><code>constructor</code></td><td>合约部署时执行一次；可标记 <code>payable</code>（部署时接收 ETH）</td><td>初始化状态变量（如设置合约 owner、token 名称）</td></tr><tr><td></td><td><code>receive()</code></td><td>接收纯 ETH 转账时触发；必须 <code>external payable</code>，无参数无返回值</td><td>处理用户直接转账 ETH 的逻辑</td></tr><tr><td></td><td><code>fallback()</code></td><td>调用不存在的函数/带数据的转账时触发；必须 <code>external payable</code></td><td>处理未知调用，兜底逻辑</td></tr><tr><td><strong>多返回值</strong></td><td>语法</td><td>支持多值返回；可命名返回值；支持解构赋值（忽略部分值用 <code>,</code>）</td><td>一次性返回多个相关数据（如数字、布尔值、字符串）</td></tr></tbody></table></div><footer class=post-footer><ul class=post-tags><li><a href=https://flash122u.github.io/tags/solidity/>Solidity</a></li><li><a href=https://flash122u.github.io/tags/web3/>Web3</a></li><li><a href=https://flash122u.github.io/tags/eth/>ETH</a></li></ul><nav class=paginav><a class=prev href=https://flash122u.github.io/posts/web3_mod/><span class=title>« Prev</span><br><span>Web3_mod/Ambassador</span>
</a><a class=next href=https://flash122u.github.io/posts/learn-solidity/><span class=title>Next »</span><br><span>Solidity 学习记录_1</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://flash122u.github.io/>flash122u's blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>